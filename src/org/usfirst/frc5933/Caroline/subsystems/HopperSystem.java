// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc5933.Caroline.subsystems;

import org.usfirst.frc5933.Caroline.RobotMap;
import com.ctre.CANTalon;

import edu.wpi.first.wpilibj.BuiltInAccelerometer;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.interfaces.Accelerometer;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 *
 */
public class HopperSystem extends Subsystem {

	private boolean running_ = false;

	public final static double kAgitatorIncrement = 0.05;
	public final static double kAgitatorMin = 0;
	public final static double kAgitatorMax = 0.8;
	public final static double kAgitatorInitSpeed = 0.5;

	private static final boolean useAccel = false;

	private static final double kImpactThreshold = 2.5; // TEST THIS #

	private static long timeStamp2 = 0;

	private static long timeStamp = 0;

	private double agitatorSpeed_ = 0;

	private final Accelerometer accel = RobotMap.autoShutOffSensor;

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	private final SpeedController agitiatorMotor = RobotMap.hopperSystemAgitiatorMotor;

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	// Put methods for controlling this subsystem
	// here. Call these from Commands.

	public void initDefaultCommand() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// Set the default command for a subsystem here.
		// setDefaultCommand(new MySpecialCommand());
	}

	public void robotInit() {
		agitiatorMotor.setInverted(true);
	}

	public void teleopInit() {

	}

	public void autonomousInit() {

	}

	public void teleopPeriodic() {
		if (running_) {
			if (useAccel) { 
				// driver preference whether they want this assistance or not.
				// if combined acceleration vector tops threshold,
				if (accelerometerOver(kImpactThreshold)) { 
					
					// stop shooting (agitation) immediately,
					agitiatorMotor.set(0); 

					running_ = !running_; 
					// toggle running, and get out of here, 
					// you don't need to finish this method.
					return;
				}
			}
			customReversing();
		} else {
			agitiatorMotor.set(0);
		}
		//
		// SmartDashboard.putNumber("Accel x", accel.getX());
		//
		// SmartDashboard.putNumber("Accel y", accel.getY());
		//
		// SmartDashboard.putNumber("Accel z", accel.getZ());
		//
	}

	private void customReversing() {
		if (System.currentTimeMillis() < (timeStamp + 1000)) {
			agitiatorMotor.set(agitatorSpeed_);
			timeStamp2 = System.currentTimeMillis();
		}
		if (System.currentTimeMillis() > timeStamp2) {
			agitiatorMotor.set(-agitatorSpeed_);
			if (System.currentTimeMillis() > timeStamp2 + 500) {
				timeStamp = System.currentTimeMillis();
			}
		}
	}

	public void autonomousPeriodic() {
		if (running_) {
			if (useAccel) { 
				// driver preference whether they want this assistance or not.
				
				// if either left or right acceleration tops 0.5,
				// stop shooting (agitation) immediately 
				if (accelerometerOver(kImpactThreshold)) { 
					agitiatorMotor.set(0);
											
					// toggle running
					// get out of here, you don't need to finish this method.
					running_ = !running_; 
					return;
				}
			}
			agitiatorMotor.set(agitatorSpeed_);
		} else {
			agitiatorMotor.set(0);
		}
	}

	public void toggle() {
		running_ = !running_;
		agitatorSpeed_ = kAgitatorInitSpeed;
	}

	public boolean isRunnning() {
		return running_;
	}

	public void incrementAgitator() {
		agitatorSpeed_ += kAgitatorIncrement;
		if (agitatorSpeed_ > kAgitatorMax) {
			agitatorSpeed_ = kAgitatorMax;
		}
	}

	public void decrementAgitator() {
		agitatorSpeed_ -= kAgitatorIncrement;
		if (agitatorSpeed_ < kAgitatorMin) {
			agitatorSpeed_ = kAgitatorMin;
		}
	}

	/*
	 * this method combines the three vectors to get the absolute magnitude of
	 * the accelerometer's output, then compares it to a threshold to return
	 * either true if over threshold, or false if not over.
	 */
	private boolean accelerometerOver(double threshold) {

		// this is horizontal, maybe accommodate for noise?
		double x = Math.abs(accel.getX());

		// this is horizontal, maybe accommodate for noise?
		double y = Math.abs(accel.getY());
		
		// this is down, so accommodate for 1 g of force 
		// (remember, RIO is upside down)
		double z = Math.abs(accel.getZ()) - 1;
		
		// combine the three into one vector.
		// If you EVER get over 'gs', cut the hopper
		double totalMagnitude = Math.sqrt(x * x + y * y + z * z);
		SmartDashboard.putNumber("Accelerometer Magnitude ", totalMagnitude);
		if (totalMagnitude > threshold)
			return true;
		return false;
	}
}
