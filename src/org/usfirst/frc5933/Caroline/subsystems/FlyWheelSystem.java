// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc5933.Caroline.subsystems;

import org.usfirst.frc5933.Caroline.Robot;
import org.usfirst.frc5933.Caroline.RobotMap;

import com.ctre.CANTalon;
import com.ctre.CANTalon.FeedbackDevice;

import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 *
 */
public class FlyWheelSystem extends Subsystem {

	private static int counting_for_tuning_opportunities_ = 0;
	// TODO fill table out with measured values.
	private static final double[][] kInchesToSpeed = new double[][] { { 0, 0 }, { 1, 1000 }, { 2, 2000 }, { 3, 3000 },
		{ 4, 4000 }, { 5, 5000 } };

		// lookup everything: inches, (to) speed, f, p, i, and d
		private static final double[][] kLookupFlywheelSettings = new double[][] {
			// in, rpm, Fgain, P, I, D
			// 0 distance, first coordinate point
			{ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 }, // 0 ft
			{ 96, -1950, 1.8, 6.4, 0.0, 0.0 }, // second coordinate point 8
			// ft
			{ 106, -2025, 1.8, 6.9, 0.0, 0.0 }, // third 9 ft
			{ 112, -2075, 1.8, 6.5, 0.0, 0.0 }, // fourth 10 ft
			{ 118, -2100, 1.8, 6.4, 0.0, 250.0 }, // fifth 11 ft
			{ 126, -2235, 1.8, 6.4, 0.0, 275.0 }, // sixth 12 ft
			{ 135, -2250, 1.8, 6.4, 0.0, 200.0 }, // seventh 13 ft
			{ 141, -2287, 1.8, 6.0, 0.0, 0.0 }, // eighth 14 ft
			{ 148, -2325, 1.8, 5.8, 0.0, 0.0 }, // ninth 15 ft
			{ 154, -2380, 1.8, 5.4, 0.0, 0.0 }, // tenth 16 ft
			{ 160, -2420, 1.8, 5.2, 0.0, 0.0 }  // extrapolated 17 ft.
		};

		public final static float kNominalVoltage = 0;
		public final static float kPeakVoltage = 12;

		public final static double kVbusIncrement = 0.05;
		public final static double kVbusMin = 0.3;
		public final static double kVbusMax = 1;

		public final static double kSpeedIncrement = -25;
		public final static double kSpeedMin = -1500;
		public final static double kSpeedMax = -5000;

		private double vbus_ = 0.3;
		private double speed_ = -1500;

		public boolean vbus_mode = true;
		private boolean running_ = true;
		private static boolean tuning_ = true;
		private boolean using_vision = false;
		private final static boolean isWheelInverted = false;
		/*
		 * from example at
		 * https://github.com/CrossTheRoadElec/FRC-Examples/blob/master/
		 * JAVA_VelocityClosedLoop/src/org/usfirst/frc/team469/robot/Robot.java and
		 * from CIMCoder (am-3314) page:
		 * "2 channel quadrature output with 20 pulses per channel per revolution for sensing speed and direction."
		 */
		private static final int kEncoderPerRev_ = 20; // not 80 or 40
		// Pulses Per Revolution:
		// 20/channel
		// the native units are calculated by (for quadrature encoders) 4*(codes per
		// revolution)
		// so we have 4 * 20 = 80 native units per rotation

		// Calculate native units / 100 ms (the velocity calculation is perfomed
		// every 100 ms)
		// target velocity (as rotations/min) * (1 min/60sec) * (1 sec/10ms) * 80
		// upm
		// nu/100ms = (5000 / 60 / 10) * 80
		// calculate f gain (feed-forward) so 100% motor output is 5000 rpm
		// (setpoint in code)
		// f = 100% * (full forward output) / (native units per 100 ms)
		// f = 100% * 1023 / ((5000 / 60 / 10) * 80) IS MAYBE INDEPENDENT FROM
		// SYSTEM
		private static final double kFGain = 0; // feed-forward gain, was 1.5345

		// calculated p gain = (percentThrottleToFixError *
		// fullForwardOutput)/(maximumError)
		// double until motor oscillates (too much p) or is adequate for system.
		// ONLY TEST WITH SYSTEM DRAG ON MOTOR
		private static final double kPGain = 0; // p gain, was 0.22

		// smoothes motion from error to setpoint.
		// Start with 10 * pgain
		private static final double kDGain = 0; // d gain

		// If dgain doesn't quite get to setpoint, add igain
		// start with 1/100 * pgain
		private static final double kIGain = 0.0; // i gain

		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
		private final CANTalon flyWheelMotor = RobotMap.flyWheelSystemFlyWheelMotor;

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

		// Put methods for controlling this subsystem
		// here. Call these from Commands.

		public void initDefaultCommand() {
			// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


			// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

			// Set the default command for a subsystem here.
			// setDefaultCommand(new MySpecialCommand());
		}

		public void robotInit() {
			configVoltages(kNominalVoltage, kPeakVoltage);
			configFeedback();
			configFPID(0, kFGain, kPGain, kIGain, kDGain);
			flyWheelMotor.setInverted(isWheelInverted);
		}

		private void configFPID(int profileNumber, double f, double p, double i, double d) {
			/* set closed loop gains in profile 0 or profile 1 only */
			/*
			 * from example at
			 * https://github.com/CrossTheRoadElec/FRC-Examples/blob/master/
			 * JAVA_VelocityClosedLoop/src/org/usfirst/frc/team469/robot/Robot.java
			 */
			flyWheelMotor.setProfile(profileNumber);
			flyWheelMotor.setF(f);
			flyWheelMotor.setP(p);
			flyWheelMotor.setI(i);
			flyWheelMotor.setD(d);
		}

		public void teleopInit() {
			tuning_ = true;
			// TODO: Remove me later, or add into a debug conditional
			SmartDashboard.putNumber("F Gain ", kFGain);
			SmartDashboard.putNumber("P Gain ", kPGain);
			SmartDashboard.putNumber("I Gain ", kIGain);
			SmartDashboard.putNumber("D Gain ", kDGain);
			SmartDashboard.putBoolean("Tuning PID: ", tuning_);
		}

		public void autonomousInit() {
			tuning_ = false;
			running_ = false;
			setSpeed(runFancyPIDMaintenance(135));	//approx 13 ft (on the table)
													//is probably too long
		}

		private void configVoltages(float nominal, double peak) {
			flyWheelMotor.configNominalOutputVoltage(nominal, -nominal);
			flyWheelMotor.configPeakOutputVoltage(peak, -peak);
		}

		private void configFeedback() {
			flyWheelMotor.setFeedbackDevice(FeedbackDevice.QuadEncoder);
			flyWheelMotor.reverseSensor(isWheelInverted); // Sensor needs to read
			// same
			// direction as motor spins up
			// (positive-positive or negative-negative).
			flyWheelMotor.configEncoderCodesPerRev(kEncoderPerRev_);
		}

		public void setVbusMode() {
			flyWheelMotor.changeControlMode(CANTalon.TalonControlMode.PercentVbus);
			vbus_mode = true;
		}

		public void setVbus(double s) {
			setVbusMode();
			vbus_ = s;
			double vbus = getAdjustedVbus();
			flyWheelMotor.set(vbus);
			SmartDashboard.putNumber("Fly Wheel Vbus", vbus);
			if (Robot.show_debug_flywheel) {
				System.out.println("vbus: " + vbus);
			}
		}

		private void goVbus() {
			setVbusMode(); // a safety check
			double vbus = getAdjustedVbus();
			flyWheelMotor.set(vbus);
			if (Robot.show_debug_flywheel) {

				SmartDashboard.putNumber("Adjusted vbus: ", vbus);
				SmartDashboard.putNumber("Encoder Out: ", flyWheelMotor.getSpeed());
				SmartDashboard.putNumber("Closed Loop Error: ", flyWheelMotor.getClosedLoopError());
				SmartDashboard.putNumber("Motor Output Voltage: ",
						flyWheelMotor.getOutputVoltage() / flyWheelMotor.getBusVoltage());

			}
		}

		public void stop() {
			flyWheelMotor.set(0);

			if (Robot.show_debug_flywheel) {
				System.out.println("FlyWheelMotor Off");
			}
		}

		public void setSpeedMode() {
			flyWheelMotor.changeControlMode(CANTalon.TalonControlMode.Speed);
			vbus_mode = false;
		}

		public void setSpeed(double s) {
			setSpeedMode();
			speed_ = s;
			SmartDashboard.putNumber("Given speed:", s);
			if (Robot.show_debug_flywheel) {
				System.out.println("Speed: " + s);
			}
		}

		public void goSpeed() {
			setSpeedMode(); // safety check

			if (using_vision) {
				speed_ = runFancyPIDMaintenance(Robot.get_boiler_distance_height());
			}

			flyWheelMotor.set(speed_);

			if (Robot.show_debug_flywheel) {
				SmartDashboard.putNumber("Given Speed: ", speed_);
				SmartDashboard.putNumber("Encoder Out: ", flyWheelMotor.getSpeed());
				SmartDashboard.putNumber("Closed Loop Error: ", flyWheelMotor.getClosedLoopError());
				SmartDashboard.putNumber("Motor Output Voltage: ",
						flyWheelMotor.getOutputVoltage() / flyWheelMotor.getBusVoltage());
				SmartDashboard.putNumber("Maximum Out Error",
						Double.min(flyWheelMotor.getError(), SmartDashboard.getNumber("Maximum Out Error", 0.0)));
				// SmartDashboard.putNumber("Vision-based distance: ",
				// Robot.visionBoiler_.get_distance_height());
			}
 
			if (tuning_) {
				double fg = SmartDashboard.getNumber("F Gain ", 0.0);
				double pg = SmartDashboard.getNumber("P Gain ", 0.0);
				double ig = SmartDashboard.getNumber("I Gain ", 0.0);
				double dg = SmartDashboard.getNumber("D Gain ", 0.0);

				configFPID(0, fg, pg, ig, dg);
			}
		}

		public void speedUp() {
			speed_ += kSpeedIncrement;
			if (speed_ < kSpeedMax)
				speed_ = kSpeedMax;
			//
			// if (Robot.show_debug_flywheel) {
			// System.out.println("speed: " + speed_);
			// }
		}

		public void speedDown() {
			speed_ -= kSpeedIncrement;
			if (speed_ > kSpeedMin)
				speed_ = kSpeedMin;
			//
			// if (Robot.show_debug_flywheel) {
			// System.out.println("speed: " + speed_);
			// }
		}

		public void vbusDown() {
			vbus_ -= kVbusIncrement;
			if (vbus_ > kVbusMin)
				vbus_ = kVbusMin;

			// if (Robot.show_debug_flywheel) {
			// System.out.println("vbus: " + vbus_);
			// }
		}

		public void vbusUp() {
			vbus_ += kVbusIncrement;
			if (vbus_ < kVbusMax)
				vbus_ = kVbusMax;

			// if (Robot.show_debug_flywheel) {
			// System.out.println("vbus: " + vbus_);
			// }
		}

		private double getAdjustedVbus() {
			return vbus_ * kPeakVoltage / RobotMap.powerSystemPowerDistributionPanel.getVoltage();
		}

		public void teleopPeriodic() {
			if(running_){
				if (vbus_mode) {
					goVbus();
				} else {
					goSpeed();
				}
			}else{
				flyWheelMotor.set(0);
			}
		}

		public void autonomousPeriodic() {
			if(running_){
				if (vbus_mode) {
					goVbus();
				} else {
					goSpeed();
				}
			}else{
				flyWheelMotor.set(0);
			}
		}

		public void toggle() {
			running_ = !running_;
			SmartDashboard.putBoolean("Running: ", running_);
		}

		public boolean isRunnning() {
			return running_;
		}

		public void toggleVBusMode() {
			vbus_mode = !vbus_mode;
			SmartDashboard.putBoolean("Vbus mode: ", vbus_mode);
		}

		public double maintainFlywheelSpeed(double inches) {
			double rpm = runFancyPIDMaintenance(inches);
			return rpm;
		}

		private static double inchesToRpm(double inches) {
			int index = 0;
			while (kInchesToSpeed.length - 1 > index) {
				if (kInchesToSpeed[index][0] == inches) {
					return kInchesToSpeed[index][1];
				} else if ((inches > kInchesToSpeed[index][0]) && (kInchesToSpeed[index + 1][0] > inches)) {
					break;
				}
				++index;
			}

			if (index + 1 >= kInchesToSpeed.length) {
				System.err.println("Ran off the end of the RPM table");
				return 0;
			}
			// the slope intercept formulas
			// m = y2 - y1 / x2 - x1
			// b = y - mx
			// y = mx + b
			double m = (kInchesToSpeed[index + 1][1] - kInchesToSpeed[index][1])
					/ (kInchesToSpeed[index + 1][0] - kInchesToSpeed[index][0]);
			double b = kInchesToSpeed[index][1] - (m * kInchesToSpeed[index][0]);
			double y = (m * inches) + b;
			return y;
		}

		/*
		 * This method returns a 1 dimensional array that contains appropriate
		 * values for the flywheel to set itself to: rpm, f, p, i, and d values are
		 * all returned for a specialized method located directly below this one.
		 */
		private static double[] inchesToRpmPIDF(double inches) {
			int index = 0;

			while (kLookupFlywheelSettings.length - 1 > index) {
				if (kLookupFlywheelSettings[index][0] == inches) {
					return kLookupFlywheelSettings[index];
				} else if ((inches > kLookupFlywheelSettings[index][0])
						&& (kLookupFlywheelSettings[index + 1][0] > inches)) {
					break;
				}
				++index;
			}

			if (index + 1 >= kLookupFlywheelSettings.length) {
				System.err.println("Ran off the end of the RPM table");
				return kLookupFlywheelSettings[kLookupFlywheelSettings.length - 1];
			}
			// the slope intercept formulas
			// m = y2 - y1 / x2 - x1
			// b = y - mx
			// y = mx + b

			// the trick is to do this with each element in the subarray, and to
			// build
			// a return array back up
			double[] approxVals = new double[6];
			approxVals[0] = inches;

			for (int pos = 1; pos < kLookupFlywheelSettings[index].length; pos++) {
				double m = (kLookupFlywheelSettings[index + 1][pos] - kLookupFlywheelSettings[index][pos])
						/ (kLookupFlywheelSettings[index + 1][0] - kLookupFlywheelSettings[index][0]);
				double b = kLookupFlywheelSettings[index][pos] - (m * kLookupFlywheelSettings[index][0]);
				double y = (m * inches) + b;

				approxVals[pos] = y;
			}

			return approxVals;
		}

		public double runFancyPIDMaintenance(double inches) {
			double[] infoTable = inchesToRpmPIDF(inches);
			double rpm = infoTable[1];

			configFPID(0, infoTable[2], infoTable[3], infoTable[4], infoTable[5]);

			SmartDashboard.putNumber("RPM maint.", infoTable[1]);
			SmartDashboard.putNumber("F maint.", infoTable[2]);
			SmartDashboard.putNumber("P maint.", infoTable[3]);
			SmartDashboard.putNumber("I maint.", infoTable[4]);
			SmartDashboard.putNumber("D maint.", infoTable[5]);
			return rpm;
		}

		public void toggleVision() {
			using_vision = !using_vision;
			SmartDashboard.putBoolean("Using vision: ", using_vision);
		}

		public boolean usingVision(){
			return using_vision;
		}
}
