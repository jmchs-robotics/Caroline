// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc5933.Caroline.subsystems;

import org.usfirst.frc5933.Caroline.Robot;
import org.usfirst.frc5933.Caroline.RobotMap;

import com.ctre.CANTalon;
import com.ctre.CANTalon.FeedbackDevice;

import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 *
 */
public class FlyWheelSystem extends Subsystem {
	// TODO fill table out with measured values.
	private static final double[][] kInchesToSpeed = new double[][] { { 0, 0 }, { 1, 1000 }, { 2, 2000 }, { 3, 3000 },
			{ 4, 4000 }, { 5, 5000 } };

	public final static float kNominalVoltage = 0;
	public final static float kPeakVoltage = 12;

	public final static double kVbusIncrement = 0.05;
	public final static double kVbusMin = 0;
	public final static double kVbusMax = 1;

	public final static double kSpeedIncrement = 200;
	public final static double kSpeedMin = 0;
	public final static double kSpeedMax = 5000;

	private double vbus_ = 0;
	private double speed_ = 0;

	public boolean vbus_mode = false;
	private boolean running_ = true;
	private final static boolean tuning_ = false;

	/*
	 * from example at
	 * https://github.com/CrossTheRoadElec/FRC-Examples/blob/master/
	 * JAVA_VelocityClosedLoop/src/org/usfirst/frc/team469/robot/Robot.java
	 */
	private static final int kEncoderPerRev_ = 20;
	// Pulses Per Revolution:
	// 20/channel
	// the native units are calculated by (for quadrature encoders) 4*(codes per
	// revolution)
	// so we have 4 * 20 = 80 native units per rotation

	// Calculate native units / 100 ms (the velocity calculation is perfomed
	// every 100 ms)
	// target velocity (as rotations/min) * (1 min/60sec) * (1 sec/10ms) * 80
	// upm
	// nu/100ms = (5000 / 60 / 10) * 80
	// calculate f gain (feed-forward) so 100% motor output is 5000 rpm
	// (setpoint in code)
	// f = 100% * (full forward output) / (native units per 100 ms)
	// f = 100% * 1023 / ((5000 / 60 / 10) * 80) IS TECHNICALLY INDEPENDENT FROM
	// SYSTEM
	private static final double kFGain = 1.53; // feed-forward gain

	// calculated p gain = (percentThrottleToFixError *
	// fullForwardOutput)/(maximumError)
	// double until motor oscillates (too much p) or is adequate for system.
	// ONLY TEST WITH SYSTEM DRAG ON MOTOR
	private static final double kPGain = 0.0; // p gain

	// smoothes motion from error to setpoint.
	// Start with 10 * pgain
	private static final double kDGain = 0.0; // d gain

	// If dgain doesn't quite get to setpoint, add igain
	// start with 1/100 * pgain
	private static final double kIGain = 0.0; // i gain

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	private final CANTalon flyWheelMotor = RobotMap.flyWheelSystemFlyWheelMotor;

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	// Put methods for controlling this subsystem
	// here. Call these from Commands.

	public void initDefaultCommand() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// Set the default command for a subsystem here.
		// setDefaultCommand(new MySpecialCommand());
	}

	public void robotInit() {
		configVoltages(kNominalVoltage, kPeakVoltage);
		configFeedback();
		configPID(0, kFGain, kPGain, kIGain, kDGain);
		motionMagicTestInit();
	}

	private void configPID(int profileNumber, double f, double p, double i, double d) {
		/* set closed loop gains in profile 0 or profile 1 only */
		/*
		 * from example at
		 * https://github.com/CrossTheRoadElec/FRC-Examples/blob/master/
		 * JAVA_VelocityClosedLoop/src/org/usfirst/frc/team469/robot/Robot.java
		 */
		flyWheelMotor.setProfile(profileNumber);
		flyWheelMotor.setF(f);
		flyWheelMotor.setP(p);
		flyWheelMotor.setI(i);
		flyWheelMotor.setD(d);
	}

	public void teleopInit() {
		// TODO: Remove me later, or add into a debug conditional
		SmartDashboard.putNumber("F Gain ", kFGain);
		SmartDashboard.putNumber("P Gain ", kPGain);
		SmartDashboard.putNumber("I Gain ", kIGain);
		SmartDashboard.putNumber("D Gain ", kDGain);
		SmartDashboard.putBoolean("Tuning PID: ", tuning_);

		// testing motion magic
		flyWheelMotor.setPosition(0);
	}

	public void autonomousInit() {
	}

	private void configVoltages(float nominal, double peak) {
		flyWheelMotor.configNominalOutputVoltage(nominal, -nominal);
		flyWheelMotor.configPeakOutputVoltage(peak, -peak);
	}

	private void configFeedback() {
		flyWheelMotor.setFeedbackDevice(FeedbackDevice.QuadEncoder);
		flyWheelMotor.reverseSensor(false); // Sensor needs to read same
											// direction as motor spins up
											// (positive-positive).
		flyWheelMotor.configEncoderCodesPerRev(kEncoderPerRev_);
	}

	public void setVbusMode() {
		flyWheelMotor.changeControlMode(CANTalon.TalonControlMode.PercentVbus);
		vbus_mode = true;
	}

	public void setVbus(double s) {
		setVbusMode();
		vbus_ = s;
		double vbus = getAdjustedVbus();
		flyWheelMotor.set(vbus);
		SmartDashboard.putNumber("Fly Wheel Vbus", vbus);
		if (Robot.show_debug_flywheel) {
			System.out.println("vbus: " + vbus);
		}
	}

	private void goVbus() {
		setVbusMode(); // a safety check
		double vbus = getAdjustedVbus();
		flyWheelMotor.set(vbus);
		if (Robot.show_debug_flywheel) {
			System.out.println("Adjusted vbus: " + vbus);
			System.out.println("Encoder Out: " + flyWheelMotor.getSpeed());
			System.out.println("Closed Loop Error: " + flyWheelMotor.getClosedLoopError());
			System.out.println(
					"Motor Output Voltage: " + flyWheelMotor.getOutputVoltage() / flyWheelMotor.getBusVoltage());

		}
	}

	public void stop() {
		flyWheelMotor.set(0);

		if (Robot.show_debug_flywheel) {
			System.out.println("FlyWheelMotor Off");
		}
	}

	public void setSpeedMode() {
		flyWheelMotor.changeControlMode(CANTalon.TalonControlMode.Speed);
		flyWheelMotor.setInverted(false);
		vbus_mode = false;
	}

	public void setSpeed(double s) {
		setSpeedMode();
		flyWheelMotor.set(s);
		speed_ = s;
		SmartDashboard.putNumber("Fly Wheel Speed", s);
		if (Robot.show_debug_flywheel) {
			System.out.println("Speed: " + s);
		}
	}

	private void goSpeed() {
		setSpeedMode(); // safety check
		flyWheelMotor.set(speed_);
		// TODO: Remove later
		SmartDashboard.putNumber("Given speed:", speed_);
		SmartDashboard.putNumber("Encoder speed:", flyWheelMotor.getSpeed());
		SmartDashboard.putNumber("Closed Loop Error:", flyWheelMotor.getClosedLoopError());
		SmartDashboard.putNumber("Motor Output Voltage:",
				flyWheelMotor.getOutputVoltage() / flyWheelMotor.getBusVoltage());
		SmartDashboard.putNumber("Maximum Out Error",
				Double.max(flyWheelMotor.getError(), SmartDashboard.getNumber("Maximum Out Error", 0.0)));

		if (tuning_) {
			double fg = SmartDashboard.getNumber("F Gain ", 0.0);
			double pg = SmartDashboard.getNumber("P Gain ", 0.0);
			double ig = SmartDashboard.getNumber("I Gain ", 0.0);
			double dg = SmartDashboard.getNumber("D Gain ", 0.0);

			Robot.flyWheelSystem.configPID(0, fg, pg, ig, dg);
		}

		if (Robot.show_debug_flywheel) {
			System.out.println("Given Speed: " + speed_);
			System.out.println("Encoder Out: " + flyWheelMotor.getSpeed());
			System.out.println("Closed Loop Error: " + flyWheelMotor.getClosedLoopError());
			System.out.println(
					"Motor Output Voltage: " + flyWheelMotor.getOutputVoltage() / flyWheelMotor.getBusVoltage());
		}
	}

	public void speedUp() {
		speed_ += kSpeedIncrement;
		if (speed_ > kSpeedMax)
			speed_ = kSpeedMax;

		if (Robot.show_debug_flywheel) {
			System.out.println("speed: " + speed_);
		}
	}

	public void speedDown() {
		speed_ -= kSpeedIncrement;
		if (speed_ < kSpeedMin)
			speed_ = kSpeedMin;

		if (Robot.show_debug_flywheel) {
			System.out.println("speed: " + speed_);
		}
	}

	public void vbusDown() {
		vbus_ -= kVbusIncrement;
		if (vbus_ < kVbusMin)
			vbus_ = kVbusMin;

		if (Robot.show_debug_flywheel) {
			System.out.println("vbus: " + vbus_);
		}
	}

	public void vbusUp() {
		vbus_ += kVbusIncrement;
		if (vbus_ > kVbusMax)
			vbus_ = kVbusMax;

		if (Robot.show_debug_flywheel) {
			System.out.println("vbus: " + vbus_);
		}
	}

	private double getAdjustedVbus() {
		return vbus_ * kPeakVoltage / RobotMap.powerSystemPowerDistributionPanel.getVoltage();
	}

	public void teleopPeriodic() {
		SmartDashboard.putBoolean("Running? ", running_);
		SmartDashboard.putBoolean("Vbus mode? ", vbus_mode);
		if (!running_) {
			Robot.flyWheelSystem.stop();
			return;
		}
		if (vbus_mode) {
			goVbus();
		} else {
			// goSpeed();
			// testing motion magic mode:
			motionMagicTest();
		}
	}

	public void autonomousPeriodic() {
		if (vbus_mode) {
			goVbus();
		} else {
			goSpeed();
		}
	}

	public void toggle() {
		running_ = !running_;
	}

	public boolean isRunnning() {
		return running_;
	}

	public void toggleVBusMode() {
		vbus_mode = !vbus_mode;
	}

	public void motionMagicTestInit() {
		flyWheelMotor.setMotionMagicAcceleration(1200);
		flyWheelMotor.setMotionMagicCruiseVelocity(1200);
		flyWheelMotor.setPosition(0);
	}

	public void motionMagicTest() {
		flyWheelMotor.changeControlMode(CANTalon.TalonControlMode.MotionMagic);
		flyWheelMotor.set(120); // always in native units
		SmartDashboard.putNumber("Given pos:", vbus_);
		SmartDashboard.putNumber("Encoder speed:", flyWheelMotor.getSpeed());
		SmartDashboard.putNumber("Closed Loop Error:", flyWheelMotor.getClosedLoopError());
		SmartDashboard.putNumber("Encoder Pos:", flyWheelMotor.getPosition());
	}

	public void maintainFlywheelSpeed(double inches) {
		double rpm = FlyWheelSystem.inchesToRpm(inches);
		setSpeed(rpm);
	}

	private static double inchesToRpm(double inches) {
		int index = 0;
		while (kInchesToSpeed.length - 1 > index) {
			if (kInchesToSpeed[index][0] == inches) {
				return kInchesToSpeed[index][1];
			} else if ((inches > kInchesToSpeed[index][0]) && (kInchesToSpeed[index + 1][0] > inches)) {
				break;
			}
			++index;
		}

		if (index + 1 >= kInchesToSpeed.length) {
			System.err.println("Ran off the end of the RPM table");
			return 0;
		}
		// the slope intercept formulas
		// m = y2 - y1 / x2 - x1
		// b = y - mx
		// y = mx + b
		double m = (kInchesToSpeed[index + 1][1] - kInchesToSpeed[index][1])
				/ (kInchesToSpeed[index + 1][0] - kInchesToSpeed[index][0]);
		double b = kInchesToSpeed[index][1] - (m * kInchesToSpeed[index][0]);
		double y = (m * inches) + b;
		return y;
	}

}
