// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc5933.Caroline.subsystems;

import org.usfirst.frc5933.Caroline.Robot;
import org.usfirst.frc5933.Caroline.RobotMap;

import com.ctre.CANTalon;
import com.ctre.CANTalon.FeedbackDevice;

import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 *
 */
public class FlyWheelSystem extends Subsystem {

	public final static float kNominalVoltage = 0;
	public final static float kPeakVoltage = 12;

	public final static double kVbusIncrement = 0.05;
	public final static double kVbusMin = 0;
	public final static double kVbusMax = 1;

	public final static double kSpeedIncrement = 200;
	public final static double kSpeedMin = 0;
	public final static double kSpeedMax = 5000;

	private double vbus_ = 0;
	private double speed_ = 0;

	public boolean vbus_mode = false;
	private boolean running_ = true; 
	private final static boolean tuning_ = false;
	
	private int i_ = 00;

	/* from example at 
	https://github.com/CrossTheRoadElec/FRC-Examples/blob/master/JAVA_VelocityClosedLoop/src/org/usfirst/frc/team469/robot/Robot.java */
	private static final int kEncoderPerRev_ = 20;
	// Pulses Per Revolution:
	// 20/channel
	// the native units are calculated by (for quadrature encoders) 4*(codes per revolution) 
	// so we have 4 * 20 = 80 native units per rotation

	//Calculate native units / 100 ms (the velocity calculation is perfomed every 100 ms)
	//target velocity (as rotations/min) * (1 min/60sec) * (1 sec/10ms) * 80 upm
	//nu/100ms = (5000 / 60 / 10) * 80
	//calculate f gain (feed-forward) so 100% motor output is 5000 rpm (setpoint in code)
	//f = 100% * (full forward output) / (native units per 100 ms)
	//f = 100% * 1023 / ((5000 / 60 / 10) * 80)						IS TECHNICALLY INDEPENDENT FROM SYSTEM
	private static final double kFGain = 1.53; //feed-forward gain

	//calculated p gain = (percentThrottleToFixError * fullForwardOutput)/(maximumError)
	//double until motor oscillates (too much p) or is adequate for system. ONLY TEST WITH SYSTEM DRAG ON MOTOR
	private static final double kPGain = 0.0; //p gain

	//smoothes motion from error to setpoint. 
	//Start with 10 * pgain
	private static final double kDGain = 0.0; //d gain

	//If dgain doesn't quite get to setpoint, add igain
	//start with 1/100 * pgain
	private static final double kIGain = 0.0; //i gain


	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	private final CANTalon flyWheelMotor = RobotMap.flyWheelSystemFlyWheelMotor;

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	// Put methods for controlling this subsystem
	// here. Call these from Commands.

	public void initDefaultCommand() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// Set the default command for a subsystem here.
		// setDefaultCommand(new MySpecialCommand());
	}

	public void robotInit() {
		configVoltages(kNominalVoltage, kPeakVoltage);
		configFeedback();
		configPID(0,kFGain,kPGain,kIGain,kDGain);
		motionMagicTestInit();
	}

	private void configPID(int profileNumber, double f, double p, double i, double d) {
		/*set closed loop gains in profile 0 or profile 1 only*/
		/* from example at 
https://github.com/CrossTheRoadElec/FRC-Examples/blob/master/JAVA_VelocityClosedLoop/src/org/usfirst/frc/team469/robot/Robot.java */
		flyWheelMotor.setProfile(profileNumber);
		flyWheelMotor.setF(f);
		flyWheelMotor.setP(p);
		flyWheelMotor.setI(i);
		flyWheelMotor.setD(d);
	}

	public void teleopInit() {
		SmartDashboard.putNumber("F Gain ", kFGain);
		SmartDashboard.putNumber("P Gain ", kPGain);
		SmartDashboard.putNumber("I Gain ", kIGain);
		SmartDashboard.putNumber("D Gain ", kDGain);
		SmartDashboard.putBoolean("Tuning PID: ", tuning_);
		
		// testing motion magic
		flyWheelMotor.setPosition(0);
	}

	public void autonomousInit() {
	}

	private void configVoltages(float nominal, double peak) {
		flyWheelMotor.configNominalOutputVoltage(nominal, -nominal);
		flyWheelMotor.configPeakOutputVoltage(peak, -peak);
	}

	private void configFeedback() {
		flyWheelMotor.setFeedbackDevice(FeedbackDevice.QuadEncoder);
		flyWheelMotor.reverseSensor(false); // Sensor needs to read same direction as motor spins up (positive-positive).
		flyWheelMotor.configEncoderCodesPerRev(kEncoderPerRev_);
	}

	public void setVbusMode() {
		flyWheelMotor.changeControlMode(CANTalon.TalonControlMode.PercentVbus);
		vbus_mode = true;
	}

	public void setVbus(double s) {
		setVbusMode();
		vbus_ = s;
		double vbus = getAdjustedVbus();
		flyWheelMotor.set(vbus);
		SmartDashboard.putNumber("Fly Wheel Vbus", vbus);
		if (Robot.show_debug_flywheel) {
			System.out.println("vbus: " + vbus);
		}
	}

	private void goVbus() {
		setVbusMode();					//a safety check
		double vbus = getAdjustedVbus();
		flyWheelMotor.set(vbus);
		if (Robot.show_debug_flywheel) {
			System.out.println("Adjusted vbus: " + vbus);
			System.out.println("Encoder Out: " + flyWheelMotor.getSpeed());
			System.out.println("Closed Loop Error: " + flyWheelMotor.getClosedLoopError());
			System.out.println("Motor Output Voltage: " + flyWheelMotor.getOutputVoltage()/flyWheelMotor.getBusVoltage());

		}
	}

	public void stop() {
		flyWheelMotor.set(0);

		if (Robot.show_debug_flywheel) {
			System.out.println("FlyWheelMotor Off");
		}
	}

	public void setSpeedMode() {
		flyWheelMotor.changeControlMode(CANTalon.TalonControlMode.Speed);
		flyWheelMotor.setInverted(false);
		vbus_mode = false;
	}

	public void setSpeed(double s) {
		setSpeedMode();
		flyWheelMotor.set(s);
		speed_ = s;
		SmartDashboard.putNumber("Fly Wheel Speed", s);
		if (Robot.show_debug_flywheel) {
			System.out.println("Speed: " + s);
		}
	}

	private void goSpeed() {
		setSpeedMode();				//safety check
		flyWheelMotor.set(speed_);
		SmartDashboard.putNumber("Given speed:", speed_);
		SmartDashboard.putNumber("Encoder speed:", flyWheelMotor.getSpeed());
		SmartDashboard.putNumber("Closed Loop Error:", flyWheelMotor.getClosedLoopError());
		SmartDashboard.putNumber("Motor Output Voltage:", flyWheelMotor.getOutputVoltage()/flyWheelMotor.getBusVoltage());
		SmartDashboard.putNumber("Maximum Out Error", Double.max(flyWheelMotor.getError(), SmartDashboard.getNumber("Maximum Out Error",0.0)));

		if(tuning_){
			double fg = SmartDashboard.getNumber("F Gain ", 0.0);
			double pg = SmartDashboard.getNumber("P Gain ", 0.0);
			double ig = SmartDashboard.getNumber("I Gain ", 0.0);
			double dg = SmartDashboard.getNumber("D Gain ", 0.0);

			Robot.flyWheelSystem.configPID(0, fg, pg, ig, dg);
		}

		if (Robot.show_debug_flywheel) {
			System.out.println("Given Speed: " + speed_);
			System.out.println("Encoder Out: " + flyWheelMotor.getSpeed());
			System.out.println("Closed Loop Error: " + flyWheelMotor.getClosedLoopError());
			System.out.println("Motor Output Voltage: " + flyWheelMotor.getOutputVoltage()/flyWheelMotor.getBusVoltage());
		}
	}

	public void speedUp() {
		speed_ += kSpeedIncrement;
		if (speed_ > kSpeedMax)
			speed_ = kSpeedMax;

		if (Robot.show_debug_flywheel) {
			System.out.println("speed: " + speed_);
		}
	}

	public void speedDown() {
		speed_ -= kSpeedIncrement;
		if (speed_ < kSpeedMin)
			speed_ = kSpeedMin;

		if (Robot.show_debug_flywheel) {
			System.out.println("speed: " + speed_);
		}
	}

	public void vbusDown() {
		vbus_ -= kVbusIncrement;
		if (vbus_ < kVbusMin)
			vbus_ = kVbusMin;

		if (Robot.show_debug_flywheel) {
			System.out.println("vbus: " + vbus_);
		}
	}

	public void vbusUp() {
		vbus_ += kVbusIncrement;
		if (vbus_ > kVbusMax)
			vbus_ = kVbusMax;

		if (Robot.show_debug_flywheel) {
			System.out.println("vbus: " + vbus_);
		}
	}

	private double getAdjustedVbus() {
		return vbus_ * kPeakVoltage / RobotMap.powerSystemPowerDistributionPanel.getVoltage();
	}

	public void teleopPeriodic() {
		SmartDashboard.putBoolean("Running? ", running_);
		SmartDashboard.putBoolean("Vbus mode? ",vbus_mode);
		if(!running_){
			Robot.flyWheelSystem.stop();
			return;
		}
		if (vbus_mode) {
			goVbus();
		} else {
//			goSpeed();
			// testing motion magic mode:
			motionMagicTest();
		}
	}

	public void autonomousPeriodic() {
		if (vbus_mode) {
			goVbus();
		} else {
			goSpeed();
		}
	}

	public void toggle() {
		running_ = !running_;
	}

	public boolean isRunnning() {
		return running_;
	}

	public void toggleVBusMode() {
		vbus_mode = !vbus_mode;
	}

	public void motionMagicTestInit(){
		flyWheelMotor.setMotionMagicAcceleration(1200);
		flyWheelMotor.setMotionMagicCruiseVelocity(1200);
		flyWheelMotor.setPosition(0);
		//flyWheelMotor.setEncPosition(0);
	}

	public void motionMagicTest(){
		//flyWheelMotor.pushMotionProfileTrajectory(trajPt);
		flyWheelMotor.changeControlMode(CANTalon.TalonControlMode.MotionMagic);
		flyWheelMotor.set(120);
		SmartDashboard.putNumber("Given pos:", vbus_);
		SmartDashboard.putNumber("Encoder speed:", flyWheelMotor.getSpeed());
		SmartDashboard.putNumber("Closed Loop Error:", flyWheelMotor.getClosedLoopError());
		SmartDashboard.putNumber("Encoder Pos:", flyWheelMotor.getPosition());
	}
}

