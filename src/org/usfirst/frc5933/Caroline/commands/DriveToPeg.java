// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc5933.Caroline.commands;

import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.interfaces.Accelerometer;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import org.usfirst.frc5933.Caroline.Robot;
import org.usfirst.frc5933.Caroline.RobotMap;
import org.usfirst.frc5933.Caroline.SocketVision;

/**
 *
 */
public class DriveToPeg extends Command {
	private static boolean finished = false;
	private static final double kAcceptableDist = 0; //a good distance for the robot to stop under, so the peg will always be grabbed. EXPERIMENTALLY DETERMINED
	private static final double kDegrees_x_divisor = 960; //used in some math to make sure the change of speed doesn't exceed 0.2
	private static final double kDefaultDriveSpeed = 0.20;
	private static final double kMaxImpact = 2.5;
	private static Accelerometer accel = RobotMap.autoShutOffSensor;
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
	public DriveToPeg() {

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.driveTrainSystem);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	}

	// Called just before this Command runs the first time
	protected void initialize() {
		SmartDashboard.putString("driveToPeg interupted.", "pickles");
		SmartDashboard.putBoolean("Peg vision good? ", !(Robot.visionPeg_ == null));
		finished = false;
	}

	// Called repeatedly when this Command is scheduled to run
	protected void execute() {
		if (Robot.visionPeg_ == null) {
			System.out.println("visionPeg_ null");
			return;
		}
		
		if(!Robot.visionPeg_.is_connected()){
			System.out.println("visionPeg_ not connected");
			return;
		}
		
		double dist = Robot.visionPeg_.get_distance_height();
		
		if((dist <= kAcceptableDist && (!(dist <= -0.99) && !(dist >= -1.01))) || accelerometerOver(kMaxImpact))
			finished = true;	//the gear is delivered

		if(!finished){
			double x_dist = Robot.visionPeg_.get_degrees_x();
			double driveSpeedModifier = Math.abs(x_dist / kDegrees_x_divisor);	//This is so maximum error will only change the speed by .25
			if (driveSpeedModifier > 0.2)
				driveSpeedModifier = 0.2;								//safety catch for above reason

			String dir = Robot.visionPeg_.get_direction();		//cause modifier is always positive
			
			//TODO: remove later
			SmartDashboard.putNumber("Peg degrees_x ", x_dist);
			SmartDashboard.putNumber("Speed modifier: ", driveSpeedModifier);
			SmartDashboard.putString("Direction ", dir);
			SmartDashboard.putNumber("Distance: ", dist);
			
			switch(dir){
			case SocketVision.NADA:
				Robot.driveTrainSystem.set(kDefaultDriveSpeed, kDefaultDriveSpeed);		//0.5 may be too fast, change var in top.
				break;
			case SocketVision.LEFT:
				Robot.driveTrainSystem.set(kDefaultDriveSpeed - driveSpeedModifier, kDefaultDriveSpeed);	//always slow down the side you want to turn to. Kinda like a boat's rudder.
				break;
			case SocketVision.RIGHT:
				Robot.driveTrainSystem.set(kDefaultDriveSpeed, kDefaultDriveSpeed - driveSpeedModifier);
				break;
			default:
				Robot.driveTrainSystem.set(kDefaultDriveSpeed / 2, kDefaultDriveSpeed / 2); //go slower if something isn't working

				if(Robot.show_debug_vision){
					System.err.println("Socket failed");
				}

				break;
			}
		}
	}

	/*
	 *this method combines the three vectors to get the absolute magnitude of
	 *the accelerometer's output, then compares it to a threshold to return either
	 *true if over threshold, or false if not over. 
	 */
	private boolean accelerometerOver(double threshold){
		double x = Math.abs(accel.getX()); 		//this is horizontal, maybe accommodate for noise?
		double y = Math.abs(accel.getY()); 		//this is horizontal, maybe accommodate for noise?
		double z = Math.abs(accel.getZ()) - 1;	//this is down, so accommodate for 1 g of force (remember, RIO is upside down)
		double totalMagnitude = Math.sqrt(x*x + y*y + z*z);		//combine the three into one vector. If you EVER get over 'threshold', cut the motors
		SmartDashboard.putNumber("Accelerometer Magnitude ", totalMagnitude);
		if(totalMagnitude > threshold)
			return true;
		return false;
	}
	
	// Make this return true when this Command no longer needs to run execute()
	protected boolean isFinished() {
		return finished;
	}

	// Called once after isFinished returns true
	protected void end() {
		Robot.driveTrainSystem.stop();
	}

	// Called when another command which requires one or more of the same
	// subsystems is scheduled to run
	protected void interrupted() {
		SmartDashboard.putString("driveToPeg interupted.", "fudge");
		end();
	}
}
